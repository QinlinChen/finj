/* Generated by genhack.py */
#include "../config.h"
#include "../sys.h"

#include <stdarg.h>
#include <grp.h>
#include <pwd.h>
#include <dirent.h>
#include <sys/mman.h>

#include "../core/core.h"
#include "../core/utils.h"

int finj_open(const char *file, const char *caller, int line, const char * pathname, int flags, ...)
{
    if (checkpoint("open", file, caller, line)) {
        static int table[] = {
            EACCES, EEXIST, EFAULT, EINTR, EINVAL, EISDIR, ELOOP, ENAMETOOLONG, ENFILE, ENOENT, ENOSPC, ENOTDIR, EOVERFLOW, EPERM
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }

    mode_t mode = 0;
    if (flags & O_CREAT) {
        va_list ap;
        va_start (ap, flags);
        mode = va_arg (ap, mode_t);
        va_end (ap);
    }

    return open(pathname, flags, mode);
}

int finj_openat(const char *file, const char *caller, int line, int dirfd, const char * pathname, int flags, ...)
{
    if (checkpoint("openat", file, caller, line)) {
        static int table[] = {
            EACCES, EEXIST, EFAULT, EINTR, EINVAL, EISDIR, ELOOP, ENAMETOOLONG, ENFILE, ENOENT, ENOSPC, ENOTDIR, EOVERFLOW, EPERM
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }

    mode_t mode = 0;
    if (flags & O_CREAT) {
        va_list ap;
        va_start (ap, flags);
        mode = va_arg (ap, mode_t);
        va_end (ap);
    }

    return openat(dirfd, pathname, flags, mode);
}


void * finj_malloc(const char *file, const char *caller, int line, size_t size)
{
    if (checkpoint("malloc", file, caller, line)) {
        static int table[] = {
            ENOMEM
        };
        errno = RAND_CHOOSE_FROM(table);
        return NULL;
    }
    return malloc(size);
}

void * finj_calloc(const char *file, const char *caller, int line, size_t nmemb, size_t size)
{
    if (checkpoint("calloc", file, caller, line)) {
        static int table[] = {
            ENOMEM
        };
        errno = RAND_CHOOSE_FROM(table);
        return NULL;
    }
    return calloc(nmemb, size);
}

void * finj_realloc(const char *file, const char *caller, int line, void * ptr, size_t size)
{
    if (checkpoint("realloc", file, caller, line)) {
        static int table[] = {
            ENOMEM
        };
        errno = RAND_CHOOSE_FROM(table);
        return NULL;
    }
    return realloc(ptr, size);
}

void * finj_mmap(const char *file, const char *caller, int line, void * addr, size_t length, int prot, int flags, int fd, off_t offset)
{
    if (checkpoint("mmap", file, caller, line)) {
        static int table[] = {
            EACCES, EAGAIN, EBADF, EINVAL, ENFILE, ENODEV, ENOMEM, EPERM, ETXTBSY, EOVERFLOW
        };
        errno = RAND_CHOOSE_FROM(table);
        return MAP_FAILED;
    }
    return mmap(addr, length, prot, flags, fd, offset);
}

int finj_fstat(const char *file, const char *caller, int line, int fd, struct stat * buf)
{
    if (checkpoint("fstat", file, caller, line)) {
        static int table[] = {
            EACCES, EBADF, EFAULT, ELOOP, ENAMETOOLONG, ENOENT, ENOMEM, ENOTDIR, EOVERFLOW
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return fstat(fd, buf);
}

int finj_lstat(const char *file, const char *caller, int line, const char * pathname, struct stat * buf)
{
    if (checkpoint("lstat", file, caller, line)) {
        static int table[] = {
            EACCES, EBADF, EFAULT, ELOOP, ENAMETOOLONG, ENOENT, ENOMEM, ENOTDIR, EOVERFLOW
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return lstat(pathname, buf);
}

int finj_fstatat(const char *file, const char *caller, int line, int dirfd, const char * pathname, struct stat * buf, int flags)
{
    if (checkpoint("fstatat", file, caller, line)) {
        static int table[] = {
            EACCES, EBADF, EFAULT, ELOOP, ENAMETOOLONG, ENOENT, ENOMEM, ENOTDIR, EOVERFLOW, EBADF, EINVAL, ENOTDIR
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return fstatat(dirfd, pathname, buf, flags);
}

int finj_creat(const char *file, const char *caller, int line, const char * pathname, mode_t mode)
{
    if (checkpoint("creat", file, caller, line)) {
        static int table[] = {
            EACCES, EEXIST, EFAULT, EINTR, EINVAL, EISDIR, ELOOP, ENAMETOOLONG, ENFILE, ENOENT, ENOSPC, ENOTDIR, EOVERFLOW, EPERM
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return creat(pathname, mode);
}

off_t finj_lseek(const char *file, const char *caller, int line, int fd, off_t offset, int whence)
{
    if (checkpoint("lseek", file, caller, line)) {
        static int table[] = {
            EBADF, EINVAL, EOVERFLOW, ESPIPE, ENXIO
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return lseek(fd, offset, whence);
}

ssize_t finj_read(const char *file, const char *caller, int line, int fd, void * buf, size_t count)
{
    if (checkpoint("read", file, caller, line)) {
        static int table[] = {
            EAGAIN, EBADF, EFAULT, EINTR, EINVAL, EIO, EISDIR
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return read(fd, buf, count);
}

ssize_t finj_write(const char *file, const char *caller, int line, int fd, const void * buf, size_t count)
{
    if (checkpoint("write", file, caller, line)) {
        static int table[] = {
            EAGAIN, EBADF, EDESTADDRREQ, EDQUOT, EFAULT, EFBIG, EINTR, EINVAL, EIO, ENOSPC, EPERM, EPIPE
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return write(fd, buf, count);
}

int finj_close(const char *file, const char *caller, int line, int fd)
{
    if (checkpoint("close", file, caller, line)) {
        static int table[] = {
            EBADF, EINTR, EIO
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return close(fd);
}

FILE * finj_fopen(const char *file, const char *caller, int line, const char * path, const char * mode)
{
    if (checkpoint("fopen", file, caller, line)) {
        static int table[] = {
            ENOMEM, EACCES, EEXIST, EFAULT, EINTR, EINVAL, EISDIR, ELOOP, ENAMETOOLONG, ENFILE, ENOENT, ENOSPC, ENOTDIR, EOVERFLOW, EPERM
        };
        errno = RAND_CHOOSE_FROM(table);
        return NULL;
    }
    return fopen(path, mode);
}

FILE * finj_fdopen(const char *file, const char *caller, int line, int fd, const char * mode)
{
    if (checkpoint("fdopen", file, caller, line)) {
        static int table[] = {
            EINVAL, ENOMEM
        };
        errno = RAND_CHOOSE_FROM(table);
        return NULL;
    }
    return fdopen(fd, mode);
}

FILE * finj_freopen(const char *file, const char *caller, int line, const char * path, const char * mode, FILE * stream)
{
    if (checkpoint("freopen", file, caller, line)) {
        static int table[] = {
            ENOMEM, EACCES, EEXIST, EFAULT, EINTR, EINVAL, EISDIR, ELOOP, ENAMETOOLONG, ENFILE, ENOENT, ENOSPC, ENOTDIR, EOVERFLOW, EPERM
        };
        errno = RAND_CHOOSE_FROM(table);
        return NULL;
    }
    return freopen(path, mode, stream);
}

int finj_rename(const char *file, const char *caller, int line, const char * oldpath, const char * newpath)
{
    if (checkpoint("rename", file, caller, line)) {
        static int table[] = {
            EACCES, EBUSY, EDQUOT, EFAULT, EINVAL, EISDIR, ELOOP, EMLINK, ENAMETOOLONG, ENOENT, ENOMEM, ENOSPC, ENOTDIR, ENOTEMPTY, EEXIST, EPERM, EROFS, EXDEV
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return rename(oldpath, newpath);
}

int finj_renameat(const char *file, const char *caller, int line, int olddirfd, const char * oldpath, int newdirfd, const char * newpath)
{
    if (checkpoint("renameat", file, caller, line)) {
        static int table[] = {
            EACCES, EBUSY, EDQUOT, EFAULT, EINVAL, EISDIR, ELOOP, EMLINK, ENAMETOOLONG, ENOENT, ENOMEM, ENOSPC, ENOTDIR, ENOTEMPTY, EEXIST, EPERM, EROFS, EXDEV
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return renameat(olddirfd, oldpath, newdirfd, newpath);
}

int finj_link(const char *file, const char *caller, int line, const char * oldpath, const char * newpath)
{
    if (checkpoint("link", file, caller, line)) {
        static int table[] = {
            EACCES, EDQUOT, EEXIST, EFAULT, EIO, ELOOP, EMLINK, ENAMETOOLONG, ENOENT, ENOMEM, ENOSPC, ENOTDIR, EPERM, EROFS, EXDEV
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return link(oldpath, newpath);
}

int finj_linkat(const char *file, const char *caller, int line, int olddirfd, const char * oldpath, int newdirfd, const char * newpath, int flags)
{
    if (checkpoint("linkat", file, caller, line)) {
        static int table[] = {
            EACCES, EBUSY, EDQUOT, EFAULT, EINVAL, EISDIR, ELOOP, EMLINK, ENAMETOOLONG, ENOENT, ENOMEM, ENOSPC, ENOTDIR, ENOTEMPTY, EEXIST, EPERM, EROFS, EXDEV
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return linkat(olddirfd, oldpath, newdirfd, newpath, flags);
}

int finj_unlink(const char *file, const char *caller, int line, const char * pathname)
{
    if (checkpoint("unlink", file, caller, line)) {
        static int table[] = {
            EACCES, EBUSY, EFAULT, EIO, EISDIR, ELOOP, ENAMETOOLONG, ENOENT, ENOMEM, ENOTDIR, EPERM, EROFS
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return unlink(pathname);
}

int finj_unlinkat(const char *file, const char *caller, int line, int dirfd, const char * pathname, int flags)
{
    if (checkpoint("unlinkat", file, caller, line)) {
        static int table[] = {
            EACCES, EBUSY, EFAULT, EIO, EISDIR, ELOOP, ENAMETOOLONG, ENOENT, ENOMEM, ENOTDIR, EPERM, EROFS, EBADF, EINVAL
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return unlinkat(dirfd, pathname, flags);
}

int finj_truncate(const char *file, const char *caller, int line, const char * path, off_t length)
{
    if (checkpoint("truncate", file, caller, line)) {
        static int table[] = {
            EACCES, EFAULT, EFBIG, EINTR, EINVAL, EIO, EISDIR, ELOOP, ENAMETOOLONG, ENOENT, ENOTDIR, EPERM, EROFS, ETXTBSY
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return truncate(path, length);
}

int finj_ftruncate(const char *file, const char *caller, int line, int fd, off_t length)
{
    if (checkpoint("ftruncate", file, caller, line)) {
        static int table[] = {
            EACCES, EFAULT, EFBIG, EINTR, EINVAL, EIO, EISDIR, ELOOP, ENAMETOOLONG, ENOENT, ENOTDIR, EPERM, EROFS, ETXTBSY
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return ftruncate(fd, length);
}

int finj_remove(const char *file, const char *caller, int line, const char * pathname)
{
    if (checkpoint("remove", file, caller, line)) {
        static int table[] = {
            EACCES, EBUSY, EFAULT, EIO, EISDIR, ELOOP, ENAMETOOLONG, ENOENT, ENOMEM, ENOTDIR, EPERM, EROFS
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return remove(pathname);
}

int finj_symlink(const char *file, const char *caller, int line, const char * target, const char * linkpath)
{
    if (checkpoint("symlink", file, caller, line)) {
        static int table[] = {
            EACCES, EDQUOT, EEXIST, EFAULT, EIO, ELOOP, ENAMETOOLONG, ENOENT, ENOMEM, ENOSPC, ENOTDIR, EPERM, EROFS
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return symlink(target, linkpath);
}

int finj_symlinkat(const char *file, const char *caller, int line, const char * target, int newdirfd, const char * linkpath)
{
    if (checkpoint("symlinkat", file, caller, line)) {
        static int table[] = {
            EACCES, EDQUOT, EEXIST, EFAULT, EIO, ELOOP, ENAMETOOLONG, ENOENT, ENOMEM, ENOSPC, ENOTDIR, EPERM, EROFS
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return symlinkat(target, newdirfd, linkpath);
}

DIR * finj_opendir(const char *file, const char *caller, int line, const char * name)
{
    if (checkpoint("opendir", file, caller, line)) {
        static int table[] = {
            EACCES, EBADF, EMFILE, ENFILE, ENOENT, ENOMEM, ENOTDIR
        };
        errno = RAND_CHOOSE_FROM(table);
        return NULL;
    }
    return opendir(name);
}

DIR * finj_fdopendir(const char *file, const char *caller, int line, int fd)
{
    if (checkpoint("fdopendir", file, caller, line)) {
        static int table[] = {
            EACCES, EBADF, EMFILE, ENFILE, ENOENT, ENOMEM, ENOTDIR
        };
        errno = RAND_CHOOSE_FROM(table);
        return NULL;
    }
    return fdopendir(fd);
}

int finj_mkdir(const char *file, const char *caller, int line, const char * pathname, mode_t mode)
{
    if (checkpoint("mkdir", file, caller, line)) {
        static int table[] = {
            EACCES, EDQUOT, EEXIST, EFAULT, ELOOP, EMLINK, ENAMETOOLONG, ENOENT, ENOMEM, ENOSPC, ENOTDIR, EPERM, EROFS
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return mkdir(pathname, mode);
}

int finj_mkdirat(const char *file, const char *caller, int line, int dirfd, const char * pathname, mode_t mode)
{
    if (checkpoint("mkdirat", file, caller, line)) {
        static int table[] = {
            EACCES, EDQUOT, EEXIST, EFAULT, ELOOP, EMLINK, ENAMETOOLONG, ENOENT, ENOMEM, ENOSPC, ENOTDIR, EPERM, EROFS, EBADF
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return mkdirat(dirfd, pathname, mode);
}

int finj_rmdir(const char *file, const char *caller, int line, const char * pathname)
{
    if (checkpoint("rmdir", file, caller, line)) {
        static int table[] = {
            EACCES, EBUSY, EFAULT, EINVAL, ELOOP, ENAMETOOLONG, ENOENT, ENOMEM, ENOTDIR, ENOTEMPTY, EPERM, EROFS
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return rmdir(pathname);
}

char * finj_mkdtemp(const char *file, const char *caller, int line, char * template)
{
    if (checkpoint("mkdtemp", file, caller, line)) {
        static int table[] = {
            EINVAL, EACCES, EDQUOT, EEXIST, EFAULT, ELOOP, EMLINK, ENAMETOOLONG, ENOENT, ENOMEM, ENOSPC, ENOTDIR, EPERM, EROFS
        };
        errno = RAND_CHOOSE_FROM(table);
        return NULL;
    }
    return mkdtemp(template);
}

int finj_mkstemp(const char *file, const char *caller, int line, char * template)
{
    if (checkpoint("mkstemp", file, caller, line)) {
        static int table[] = {
            EACCES, EEXIST, EFAULT, EINTR, EINVAL, EISDIR, ELOOP, ENAMETOOLONG, ENFILE, ENOENT, ENOSPC, ENOTDIR, EOVERFLOW, EPERM
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return mkstemp(template);
}

int finj_mkfifo(const char *file, const char *caller, int line, const char * pathname, mode_t mode)
{
    if (checkpoint("mkfifo", file, caller, line)) {
        static int table[] = {
            EACCES, EDQUOT, EEXIST, ENAMETOOLONG, ENOENT, ENOSPC, ENOTDIR, EROFS
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return mkfifo(pathname, mode);
}

int finj_mkfifoat(const char *file, const char *caller, int line, int dirfd, const char * pathname, mode_t mode)
{
    if (checkpoint("mkfifoat", file, caller, line)) {
        static int table[] = {
            EACCES, EDQUOT, EEXIST, ENAMETOOLONG, ENOENT, ENOSPC, ENOTDIR, EROFS
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return mkfifoat(dirfd, pathname, mode);
}

int finj_dup(const char *file, const char *caller, int line, int oldfd)
{
    if (checkpoint("dup", file, caller, line)) {
        static int table[] = {
            EBADF, EBUSY, EINTR, EINVAL, EMFILE
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return dup(oldfd);
}

int finj_dup2(const char *file, const char *caller, int line, int oldfd, int newfd)
{
    if (checkpoint("dup2", file, caller, line)) {
        static int table[] = {
            EBADF, EBUSY, EINTR, EINVAL, EMFILE
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return dup2(oldfd, newfd);
}

ssize_t finj_pread(const char *file, const char *caller, int line, int fd, void * buf, size_t count, off_t offset)
{
    if (checkpoint("pread", file, caller, line)) {
        static int table[] = {
            EAGAIN, EBADF, EFAULT, EINTR, EINVAL, EIO, EISDIR
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return pread(fd, buf, count, offset);
}

ssize_t finj_pwrite(const char *file, const char *caller, int line, int fd, const void * buf, size_t count, off_t offset)
{
    if (checkpoint("pwrite", file, caller, line)) {
        static int table[] = {
            EAGAIN, EBADF, EDESTADDRREQ, EDQUOT, EFAULT, EFBIG, EINTR, EINVAL, EIO, ENOSPC, EPERM, EPIPE
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return pwrite(fd, buf, count, offset);
}

int finj_chdir(const char *file, const char *caller, int line, const char * path)
{
    if (checkpoint("chdir", file, caller, line)) {
        static int table[] = {
            EACCES, EFAULT, EIO, ELOOP, ENAMETOOLONG, ENOENT, ENOMEM, ENOTDIR
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return chdir(path);
}

int finj_fchdir(const char *file, const char *caller, int line, int fd)
{
    if (checkpoint("fchdir", file, caller, line)) {
        static int table[] = {
            EACCES, EBADF
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return fchdir(fd);
}

int finj_chown(const char *file, const char *caller, int line, const char * pathname, uid_t owner, gid_t group)
{
    if (checkpoint("chown", file, caller, line)) {
        static int table[] = {
            EACCES, EFAULT, ELOOP, ENAMETOOLONG, ENOENT, ENOMEM, ENOTDIR, EPERM, EROFS
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return chown(pathname, owner, group);
}

int finj_fchown(const char *file, const char *caller, int line, int fd, uid_t owner, gid_t group)
{
    if (checkpoint("fchown", file, caller, line)) {
        static int table[] = {
            EBADF, EIO, ENOENT, EPERM, EROFS
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return fchown(fd, owner, group);
}

int finj_lchown(const char *file, const char *caller, int line, const char * pathname, uid_t owner, gid_t group)
{
    if (checkpoint("lchown", file, caller, line)) {
        static int table[] = {
            EACCES, EFAULT, ELOOP, ENAMETOOLONG, ENOENT, ENOMEM, ENOTDIR, EPERM, EROFS
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return lchown(pathname, owner, group);
}

int finj_fchownat(const char *file, const char *caller, int line, int dirfd, const char * pathname, uid_t owner, gid_t group, int flags)
{
    if (checkpoint("fchownat", file, caller, line)) {
        static int table[] = {
            EACCES, EFAULT, ELOOP, ENAMETOOLONG, ENOENT, ENOMEM, ENOTDIR, EPERM, EROFS, EBADF, EINVAL, ENOTDIR
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return fchownat(dirfd, pathname, owner, group, flags);
}

int finj_chmod(const char *file, const char *caller, int line, const char * pathname, mode_t mode)
{
    if (checkpoint("chmod", file, caller, line)) {
        static int table[] = {
            EACCES, EFAULT, EIO, ELOOP, ENAMETOOLONG, ENOENT, ENOMEM, ENOTDIR, EPERM, EROFS
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return chmod(pathname, mode);
}

int finj_fchmod(const char *file, const char *caller, int line, int fd, mode_t mode)
{
    if (checkpoint("fchmod", file, caller, line)) {
        static int table[] = {
            EBADF, EIO, EPERM, EROFS
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return fchmod(fd, mode);
}

int finj_fchmodat(const char *file, const char *caller, int line, int dirfd, const char * pathname, mode_t mode, int flags)
{
    if (checkpoint("fchmodat", file, caller, line)) {
        static int table[] = {
            EACCES, EFAULT, EIO, ELOOP, ENAMETOOLONG, ENOENT, ENOMEM, ENOTDIR, EPERM, EROFS, EINVAL, EBADF
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return fchmodat(dirfd, pathname, mode, flags);
}

struct group * finj_getgrnam(const char *file, const char *caller, int line, const char * name)
{
    if (checkpoint("getgrnam", file, caller, line)) {
        static int table[] = {
            ENOENT, ESRCH, EBADF, EPERM, EINTR, EIO, EMFILE, ENFILE, ENOMEM, ERANGE
        };
        errno = RAND_CHOOSE_FROM(table);
        return NULL;
    }
    return getgrnam(name);
}

struct group * finj_getgrgid(const char *file, const char *caller, int line, gid_t gid)
{
    if (checkpoint("getgrgid", file, caller, line)) {
        static int table[] = {
            ENOENT, ESRCH, EBADF, EPERM, EINTR, EIO, EMFILE, ENFILE, ENOMEM, ERANGE
        };
        errno = RAND_CHOOSE_FROM(table);
        return NULL;
    }
    return getgrgid(gid);
}

struct passwd * finj_getpwnam(const char *file, const char *caller, int line, const char * name)
{
    if (checkpoint("getpwnam", file, caller, line)) {
        static int table[] = {
            ENOENT, ESRCH, EBADF, EPERM, EINTR, EIO, EMFILE, ENFILE, ENOMEM, ERANGE
        };
        errno = RAND_CHOOSE_FROM(table);
        return NULL;
    }
    return getpwnam(name);
}

struct passwd * finj_getpwuid(const char *file, const char *caller, int line, uid_t uid)
{
    if (checkpoint("getpwuid", file, caller, line)) {
        static int table[] = {
            ENOENT, ESRCH, EBADF, EPERM, EINTR, EIO, EMFILE, ENFILE, ENOMEM, ERANGE
        };
        errno = RAND_CHOOSE_FROM(table);
        return NULL;
    }
    return getpwuid(uid);
}

int finj_kill(const char *file, const char *caller, int line, pid_t pid, int sig)
{
    if (checkpoint("kill", file, caller, line)) {
        static int table[] = {
            EINVAL, EPERM, ESRCH
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return kill(pid, sig);
}

int finj_nice(const char *file, const char *caller, int line, int inc)
{
    if (checkpoint("nice", file, caller, line)) {
        static int table[] = {
            EPERM
        };
        errno = RAND_CHOOSE_FROM(table);
        return -1;
    }
    return nice(inc);
}
